# i18n Implementation Plan for Long-Term Budget

## Overview

This document provides a comprehensive implementation plan for adding internationalization (i18n) and multi-currency support to the Long-Term Budget application. The initial implementation will support English and Swedish languages, with USD and SEK currencies.

## Design Decisions

### Core Principles

1. **Decoupled Language and Currency**: Users can select any language with any currency (e.g., English with SEK, Swedish with USD)
2. **Frontend-Only Currency Formatting**: Database stores raw numeric values; currency formatting happens only in the UI
3. **No Multi-Currency Financial Data**: Users cannot mix currencies within their financial instruments (e.g., all income sources use the same currency)
4. **User Preferences**: Language and currency are stored per user in the database
5. **SSR-Compatible**: Implementation must work with Nuxt 4's server-side rendering

## Technology Stack

### Recommended: @nuxtjs/i18n v9

Use `@nuxtjs/i18n` (v9.x for Nuxt 4), which is the official i18n module for Nuxt. It's built on top of Vue I18n v10 and provides:

- Full SSR support with Nuxt 4
- Route-based locale switching (optional, but good for SEO)
- Automatic locale detection
- SEO features (alternate links, meta tags)
- TypeScript support
- Integration with Nuxt's module system

**Alternative considered**: Plain Vue I18n v10 could work but requires more manual setup and lacks Nuxt-specific features.

## Implementation Steps

### Phase 1: Setup and Configuration

#### 1.1 Install Dependencies

```bash
npm install @nuxtjs/i18n@next
```

#### 1.2 Update Nuxt Config

Add the i18n module to `nuxt.config.ts`:

```typescript
export default defineNuxtConfig({
  // ... existing config
  modules: [
    "@nuxt/eslint",
    "@nuxt/icon",
    "@nuxt/image",
    "@nuxt/test-utils",
    "@nuxt/ui",
    "@nuxt/test-utils/module",
    "@nuxtjs/i18n", // Add this
  ],
  
  i18n: {
    locales: [
      {
        code: 'en',
        iso: 'en-US',
        name: 'English',
        file: 'en.json'
      },
      {
        code: 'sv',
        iso: 'sv-SE',
        name: 'Svenska',
        file: 'sv.json'
      }
    ],
    defaultLocale: 'en',
    strategy: 'no_prefix', // Don't add locale to URLs (single-page app style)
    langDir: 'locales/',
    lazy: true, // Load translations on demand
    detectBrowserLanguage: {
      useCookie: true,
      cookieKey: 'i18n_locale',
      redirectOn: 'root',
      alwaysRedirect: false,
      fallbackLocale: 'en'
    },
    vueI18n: './i18n.config.ts' // For additional configuration
  }
})
```

**Note**: Using `strategy: 'no_prefix'` because this is a SPA-style app with authentication. If SEO is important in the future, consider using `strategy: 'prefix_except_default'`.

#### 1.3 Create i18n Config File

Create `i18n.config.ts` in the project root:

```typescript
export default defineI18nConfig(() => ({
  legacy: false, // Use Composition API mode
  locale: 'en',
  fallbackLocale: 'en',
  numberFormats: {
    en: {
      currency: {
        style: 'currency',
        currency: 'USD',
        notation: 'standard',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      },
      currencyDecimal: {
        style: 'currency',
        currency: 'USD',
        notation: 'standard',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      },
      decimal: {
        style: 'decimal',
        minimumFractionDigits: 0,
        maximumFractionDigits: 2,
      },
      percent: {
        style: 'percent',
        minimumFractionDigits: 1,
        maximumFractionDigits: 1,
      }
    },
    sv: {
      currency: {
        style: 'currency',
        currency: 'SEK',
        notation: 'standard',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      },
      currencyDecimal: {
        style: 'currency',
        currency: 'SEK',
        notation: 'standard',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      },
      decimal: {
        style: 'decimal',
        minimumFractionDigits: 0,
        maximumFractionDigits: 2,
      },
      percent: {
        style: 'percent',
        minimumFractionDigits: 1,
        maximumFractionDigits: 1,
      }
    }
  }
}))
```

**Important**: The above config uses locale-based currency formats. In Phase 2, we'll override this with user-selected currency.

### Phase 2: Database Schema Changes

#### 2.1 Add User Preferences to Users Table

Add migration to extend the `users` table with language and currency preferences:

```typescript
// database/migrations/XXXX_add_user_preferences.sql
ALTER TABLE users 
ADD COLUMN locale VARCHAR(10) DEFAULT 'en' NOT NULL,
ADD COLUMN currency VARCHAR(3) DEFAULT 'USD' NOT NULL;

COMMENT ON COLUMN users.locale IS 'User preferred language (en, sv)';
COMMENT ON COLUMN users.currency IS 'User preferred currency (USD, SEK)';
```

#### 2.2 Update Schema Definition

Update `database/schema/users.ts`:

```typescript
import {
  pgTable,
  varchar,
  timestamp,
  text,
  boolean,
} from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: text("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  emailVerified: boolean("email_verified").notNull().default(false),
  image: text("image"),
  locale: varchar("locale", { length: 10 }).notNull().default("en"),
  currency: varchar("currency", { length: 3 }).notNull().default("USD"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// ... rest of the file
```

#### 2.3 Update Validation Schema

Update `database/validation-schemas.ts` to include the new fields:

```typescript
// Add near other user-related schemas
export const updateUserPreferencesSchema = z.object({
  locale: z.enum(['en', 'sv']).optional(),
  currency: z.enum(['USD', 'SEK']).optional(),
});

export type UpdateUserPreferences = z.infer<typeof updateUserPreferencesSchema>;
```

### Phase 3: Create Translation Files

#### 3.1 Directory Structure

Create the following directory structure:

```
locales/
├── en.json
└── sv.json
```

#### 3.2 English Translations (locales/en.json)

Create comprehensive translation file. Example structure:

```json
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "close": "Close",
    "yes": "Yes",
    "no": "No",
    "confirm": "Confirm",
    "loading": "Loading...",
    "error": "Error",
    "success": "Success",
    "required": "Required"
  },
  "auth": {
    "signIn": "Sign In",
    "signOut": "Sign Out",
    "signUp": "Sign Up",
    "email": "Email",
    "password": "Password",
    "name": "Name"
  },
  "navigation": {
    "dashboard": "Dashboard",
    "economy": "Economy",
    "projections": "Projections",
    "scenarios": "Scenarios",
    "financialHealth": "Financial Health",
    "financialStory": "Financial Story"
  },
  "dashboard": {
    "title": "Users Dashboard",
    "description": "Manage application users and their accounts",
    "addUser": "Add User",
    "allUsers": "All Users",
    "noUsers": "No users yet",
    "getStarted": "Get started by adding your first user to the system."
  },
  "household": {
    "title": "Household",
    "name": "Household Name",
    "members": "Members",
    "addMember": "Add Member"
  },
  "person": {
    "name": "Name",
    "age": "Age",
    "addPerson": "Add Person",
    "editPerson": "Edit Person"
  },
  "income": {
    "title": "Income",
    "sources": "Income Sources",
    "addSource": "Add Income Source",
    "sourceName": "Source Name",
    "amount": "Amount",
    "frequency": "Frequency",
    "monthlyIncome": "Monthly Income",
    "totalIncome": "Total Income",
    "frequencies": {
      "monthly": "Monthly",
      "yearly": "Yearly",
      "weekly": "Weekly",
      "biweekly": "Bi-weekly",
      "daily": "Daily"
    }
  },
  "expenses": {
    "title": "Expenses",
    "addExpense": "Add Expense",
    "monthlyExpenses": "Monthly Expenses",
    "totalExpenses": "Total Expenses",
    "category": "Category",
    "amount": "Amount"
  },
  "savings": {
    "title": "Savings",
    "accounts": "Savings Accounts",
    "addAccount": "Add Savings Account",
    "accountName": "Account Name",
    "currentBalance": "Current Balance",
    "interestRate": "Interest Rate",
    "totalSavings": "Total Savings",
    "goals": "Savings Goals",
    "addGoal": "Add Savings Goal"
  },
  "loans": {
    "title": "Loans",
    "addLoan": "Add Loan",
    "loanName": "Loan Name",
    "originalAmount": "Original Loan Amount",
    "currentBalance": "Current Balance (Amount Still Owed)",
    "interestRate": "Interest Rate (%)",
    "monthlyPayment": "Monthly Payment",
    "loanType": "Loan Type",
    "totalDebt": "Total Debt",
    "types": {
      "mortgage": "Mortgage",
      "auto": "Auto Loan",
      "student": "Student Loan",
      "personal": "Personal Loan",
      "credit": "Credit Card",
      "other": "Other"
    }
  },
  "projections": {
    "title": "Financial Projections",
    "tenYearProjection": "10-Year Financial Projection",
    "currentSnapshot": "Current Financial Snapshot",
    "adjustAssumptions": "Adjust Assumptions",
    "resetDefaults": "Reset to Defaults",
    "assumptions": {
      "incomeGrowth": "Annual Income Growth",
      "investmentReturn": "Investment Return",
      "inflationRate": "Inflation Rate"
    },
    "milestones": "Financial Milestones",
    "summary": "10-Year Summary",
    "startingNetWorth": "Starting Net Worth",
    "endingNetWorth": "Ending Net Worth",
    "totalSaved": "Total Saved",
    "totalDebtPaid": "Total Debt Paid"
  },
  "financialHealth": {
    "title": "Financial Health",
    "netWorth": "Net Worth",
    "emergencyFund": "Emergency Fund",
    "debtToIncome": "Debt-to-Income Ratio",
    "savingsRate": "Savings Rate",
    "scores": {
      "excellent": "Excellent",
      "good": "Good",
      "fair": "Fair",
      "poor": "Poor"
    }
  },
  "settings": {
    "title": "Settings",
    "preferences": "Preferences",
    "language": "Language",
    "currency": "Currency",
    "updateSuccess": "Settings updated successfully",
    "updateError": "Failed to update settings"
  },
  "budget": {
    "categories": {
      "housing": "Housing",
      "transportation": "Transportation",
      "food": "Food & Dining",
      "utilities": "Utilities",
      "healthcare": "Healthcare",
      "entertainment": "Entertainment",
      "personal": "Personal Care",
      "education": "Education",
      "insurance": "Insurance",
      "debt": "Debt Payments",
      "savings": "Savings & Investments",
      "other": "Other"
    }
  }
}
```

#### 3.3 Swedish Translations (locales/sv.json)

Create Swedish translations. Key example sections:

```json
{
  "common": {
    "save": "Spara",
    "cancel": "Avbryt",
    "delete": "Ta bort",
    "edit": "Redigera",
    "add": "Lägg till",
    "close": "Stäng",
    "yes": "Ja",
    "no": "Nej",
    "confirm": "Bekräfta",
    "loading": "Laddar...",
    "error": "Fel",
    "success": "Lyckades",
    "required": "Obligatorisk"
  },
  "auth": {
    "signIn": "Logga in",
    "signOut": "Logga ut",
    "signUp": "Registrera",
    "email": "E-post",
    "password": "Lösenord",
    "name": "Namn"
  },
  "navigation": {
    "dashboard": "Översikt",
    "economy": "Ekonomi",
    "projections": "Prognoser",
    "scenarios": "Scenarier",
    "financialHealth": "Finansiell hälsa",
    "financialStory": "Finansiell berättelse"
  },
  "income": {
    "title": "Inkomst",
    "sources": "Inkomstkällor",
    "addSource": "Lägg till inkomstkälla",
    "sourceName": "Källans namn",
    "amount": "Belopp",
    "frequency": "Frekvens",
    "monthlyIncome": "Månadsinkomst",
    "totalIncome": "Total inkomst",
    "frequencies": {
      "monthly": "Månatlig",
      "yearly": "Årlig",
      "weekly": "Veckovis",
      "biweekly": "Varannan vecka",
      "daily": "Daglig"
    }
  },
  "loans": {
    "title": "Lån",
    "addLoan": "Lägg till lån",
    "loanName": "Lånets namn",
    "originalAmount": "Ursprungligt lånebelopp",
    "currentBalance": "Aktuellt saldo (kvarvarande skuld)",
    "interestRate": "Ränta (%)",
    "monthlyPayment": "Månadsbetalning",
    "loanType": "Lånetyp",
    "totalDebt": "Total skuld",
    "types": {
      "mortgage": "Bolån",
      "auto": "Billån",
      "student": "Studielån",
      "personal": "Privatlån",
      "credit": "Kreditkort",
      "other": "Annat"
    }
  },
  "financialHealth": {
    "title": "Finansiell hälsa",
    "netWorth": "Nettoförmögenhet",
    "emergencyFund": "Buffert",
    "debtToIncome": "Skuld-till-inkomst-förhållande",
    "savingsRate": "Sparkvot",
    "scores": {
      "excellent": "Utmärkt",
      "good": "Bra",
      "fair": "Okej",
      "poor": "Dålig"
    }
  },
  "settings": {
    "title": "Inställningar",
    "preferences": "Preferenser",
    "language": "Språk",
    "currency": "Valuta",
    "updateSuccess": "Inställningar uppdaterade",
    "updateError": "Misslyckades att uppdatera inställningar"
  },
  "budget": {
    "categories": {
      "housing": "Boende",
      "transportation": "Transport",
      "food": "Mat & Restaurang",
      "utilities": "El & Vatten",
      "healthcare": "Hälsovård",
      "entertainment": "Nöje",
      "personal": "Personlig vård",
      "education": "Utbildning",
      "insurance": "Försäkring",
      "debt": "Skuldbetalningar",
      "savings": "Sparande & Investeringar",
      "other": "Övrigt"
    }
  }
}
```

**Note**: Complete all translation keys from the English file. Above is a representative sample.

### Phase 4: Create Composables

#### 4.1 Create useUserPreferences Composable

Create `app/composables/useUserPreferences.ts`:

```typescript
import type { Ref } from 'vue'

export interface UserPreferences {
  locale: 'en' | 'sv'
  currency: 'USD' | 'SEK'
}

export const useUserPreferences = () => {
  const { $i18n } = useNuxtApp()
  const { data: session } = useAuth()

  // Fetch user preferences from the database
  const { data: preferences, refresh: refreshPreferences } = useFetch<{
    data: UserPreferences
  }>('/api/user/preferences', {
    default: () => ({ data: { locale: 'en', currency: 'USD' } }),
  })

  // Current preference values
  const locale = computed(() => preferences.value?.data?.locale ?? 'en')
  const currency = computed(() => preferences.value?.data?.currency ?? 'USD')

  // Update locale
  const setLocale = async (newLocale: 'en' | 'sv') => {
    // Update i18n
    await $i18n.setLocale(newLocale)
    
    // Update in database
    await $fetch('/api/user/preferences', {
      method: 'PATCH',
      body: { locale: newLocale }
    })
    
    await refreshPreferences()
  }

  // Update currency
  const setCurrency = async (newCurrency: 'USD' | 'SEK') => {
    // Update in database
    await $fetch('/api/user/preferences', {
      method: 'PATCH',
      body: { currency: newCurrency }
    })
    
    await refreshPreferences()
  }

  // Initialize locale from user preferences on mount
  onMounted(async () => {
    if (session.value && preferences.value?.data?.locale) {
      const userLocale = preferences.value.data.locale
      if ($i18n.locale.value !== userLocale) {
        await $i18n.setLocale(userLocale)
      }
    }
  })

  return {
    locale,
    currency,
    setLocale,
    setCurrency,
    refreshPreferences,
  }
}
```

#### 4.2 Create useCurrency Composable

Create `app/composables/useCurrency.ts`:

```typescript
/**
 * Currency formatting composable
 * Formats numbers based on user's selected currency preference
 */
export const useCurrency = () => {
  const { currency } = useUserPreferences()

  /**
   * Format a number as currency
   * @param value - The numeric value to format
   * @param options - Optional Intl.NumberFormat options
   */
  const formatCurrency = (
    value: number,
    options?: Intl.NumberFormatOptions
  ): string => {
    const currencyCode = currency.value
    
    // Determine locale based on currency
    // This ensures proper number formatting (comma vs period separators)
    const locale = currencyCode === 'SEK' ? 'sv-SE' : 'en-US'

    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currencyCode,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
      ...options,
    }).format(value)
  }

  /**
   * Format currency with decimals
   */
  const formatCurrencyDecimal = (value: number): string => {
    return formatCurrency(value, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })
  }

  /**
   * Format large currency values with abbreviations (k, M)
   */
  const formatCurrencyCompact = (value: number): string => {
    const absValue = Math.abs(value)
    const currencyCode = currency.value
    const locale = currencyCode === 'SEK' ? 'sv-SE' : 'en-US'
    
    // For Swedish, use "mn" instead of "M" for millions
    const millionSuffix = currencyCode === 'SEK' ? 'mn' : 'M'
    const thousandSuffix = currencyCode === 'SEK' ? 'k' : 'k'
    
    if (absValue >= 1_000_000) {
      const formatted = new Intl.NumberFormat(locale, {
        minimumFractionDigits: 1,
        maximumFractionDigits: 1,
      }).format(value / 1_000_000)
      return `${formatted} ${millionSuffix} ${currencyCode}`
    } else if (absValue >= 1_000) {
      const formatted = new Intl.NumberFormat(locale, {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      }).format(value / 1_000)
      return `${formatted}${thousandSuffix} ${currencyCode}`
    }
    
    return formatCurrency(value)
  }

  /**
   * Get the currency symbol
   */
  const currencySymbol = computed(() => {
    return currency.value === 'SEK' ? 'kr' : '$'
  })

  /**
   * Get the currency code
   */
  const currencyCode = computed(() => currency.value)

  return {
    formatCurrency,
    formatCurrencyDecimal,
    formatCurrencyCompact,
    currencySymbol,
    currencyCode,
    currency,
  }
}
```

### Phase 5: Backend API Endpoints

#### 5.1 Create User Preferences API

Create `server/api/user/preferences.get.ts`:

```typescript
import { db } from "~~/server/utils/db"
import { users } from "~~/database/schema"
import { eq } from "drizzle-orm"
import { successResponse, errorResponse } from "~~/server/utils/api-response"

export default defineEventHandler(async (event) => {
  const session = await requireUserSession(event)
  
  try {
    const user = await db.query.users.findFirst({
      where: eq(users.id, session.user.id),
      columns: {
        locale: true,
        currency: true,
      }
    })

    if (!user) {
      return errorResponse("User not found", 404)
    }

    return successResponse({
      locale: user.locale,
      currency: user.currency,
    })
  } catch (error) {
    console.error("Error fetching user preferences:", error)
    return errorResponse("Failed to fetch preferences")
  }
})
```

Create `server/api/user/preferences.patch.ts`:

```typescript
import { db } from "~~/server/utils/db"
import { users } from "~~/database/schema"
import { eq } from "drizzle-orm"
import { successResponse, errorResponse } from "~~/server/utils/api-response"
import { updateUserPreferencesSchema } from "~~/database/validation-schemas"

export default defineEventHandler(async (event) => {
  const session = await requireUserSession(event)
  
  try {
    const body = await readBody(event)
    const validated = updateUserPreferencesSchema.parse(body)

    const updateData: Record<string, string> = {}
    if (validated.locale) updateData.locale = validated.locale
    if (validated.currency) updateData.currency = validated.currency

    if (Object.keys(updateData).length === 0) {
      return errorResponse("No preferences to update", 400)
    }

    await db
      .update(users)
      .set({
        ...updateData,
        updatedAt: new Date(),
      })
      .where(eq(users.id, session.user.id))

    return successResponse({ message: "Preferences updated successfully" })
  } catch (error) {
    console.error("Error updating user preferences:", error)
    return errorResponse("Failed to update preferences")
  }
})
```

### Phase 6: Update Components

#### 6.1 Update Layout to Include Language Switcher

Update `app/layouts/default.vue` to add a settings/language switcher in the header:

```vue
<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900">
    <!-- Header with language/currency switcher -->
    <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
        <div>
          <!-- App title/logo -->
        </div>
        <div class="flex items-center gap-4">
          <UDropdownMenu :items="settingsMenuItems">
            <UButton 
              icon="i-heroicons-language" 
              variant="ghost"
              :label="locale.toUpperCase()"
            />
          </UDropdownMenu>
          <!-- Other header items -->
        </div>
      </div>
    </header>
    
    <!-- Main content -->
    <main>
      <slot />
    </main>
  </div>
</template>

<script setup lang="ts">
const { locale, setLocale, currency, setCurrency } = useUserPreferences()
const { t } = useI18n()

const settingsMenuItems = computed(() => [
  [
    {
      label: t('settings.language'),
      slot: 'language',
    }
  ],
  [
    {
      label: 'English',
      icon: locale.value === 'en' ? 'i-heroicons-check' : undefined,
      click: () => setLocale('en')
    },
    {
      label: 'Svenska',
      icon: locale.value === 'sv' ? 'i-heroicons-check' : undefined,
      click: () => setLocale('sv')
    }
  ],
  [
    {
      label: t('settings.currency'),
      slot: 'currency',
    }
  ],
  [
    {
      label: 'USD ($)',
      icon: currency.value === 'USD' ? 'i-heroicons-check' : undefined,
      click: () => setCurrency('USD')
    },
    {
      label: 'SEK (kr)',
      icon: currency.value === 'SEK' ? 'i-heroicons-check' : undefined,
      click: () => setCurrency('SEK')
    }
  ]
])
</script>
```

#### 6.2 Replace Currency Formatting Throughout Application

**Current Implementation Pattern:**
Many components use hardcoded currency formatting:

```typescript
// OLD - in components
const formatCurrency = (value: number) => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
};
```

**New Implementation Pattern:**
Replace with the `useCurrency` composable:

```typescript
// NEW - in components
const { formatCurrency } = useCurrency()

// Usage remains the same in template
{{ formatCurrency(totalIncome) }}
```

**Files to Update:**

1. `app/components/FinancialOverviewCards.vue` - Replace hardcoded `${{ value }}` with `{{ formatCurrency(value) }}`
2. `app/components/FinancialProjectionChart.vue` - Replace formatCurrency function with composable
3. `app/components/FinancialProjectionChartJS.vue` - Replace formatCurrency function with composable
4. `app/components/MoneyFlowVisualization.vue` - Replace formatCurrency function with composable
5. `app/components/PersonInstrumentsEditor.vue` - Replace formatCurrency function with composable
6. `app/pages/projections.vue` - Replace formatCurrency function with composable
7. `app/pages/projections-old.vue` - Replace formatCurrency function with composable
8. `app/pages/financial-story.vue` - Replace formatCurrency function with composable
9. `app/pages/financial-health.vue` - Replace formatCurrency function with composable (if exists)
10. `app/composables/useFinancialHealth.ts` - Replace formatCurrency function with composable

**Important**: For utility files used in both frontend and backend (like `utils/financial-calculations.ts`), keep them currency-agnostic. They should only deal with numeric values, not formatting.

#### 6.3 Update Text Content to Use Translations

**Example: Update IncomeSourceModal.vue**

```vue
<!-- BEFORE -->
<template>
  <UModal v-model:open="isOpen">
    <template #header>
      <h3 class="text-lg font-medium">Add Income Source</h3>
    </template>
    <!-- ... -->
    <label for="income-source-name">Source Name *</label>
    <label for="income-amount">Amount *</label>
    <label for="income-frequency">Frequency *</label>
    <!-- ... -->
  </UModal>
</template>

<!-- AFTER -->
<template>
  <UModal v-model:open="isOpen">
    <template #header>
      <h3 class="text-lg font-medium">{{ t('income.addSource') }}</h3>
    </template>
    <!-- ... -->
    <label for="income-source-name">{{ t('income.sourceName') }} *</label>
    <label for="income-amount">{{ t('income.amount') }} *</label>
    <label for="income-frequency">{{ t('income.frequency') }} *</label>
    <!-- ... -->
  </UModal>
</template>

<script setup lang="ts">
const { t } = useI18n()
// ... rest of component
</script>
```

**Apply similar updates to:**
- All modal components (LoanModal, SavingsAccountModal, etc.)
- All page components (dashboard.vue, projections.vue, etc.)
- All card components (NetWorthCard, EmergencyFundCard, etc.)
- Navigation/layout components

#### 6.4 Handle Pluralization

For dynamic text that needs pluralization, use i18n plural rules:

```json
// locales/en.json
{
  "person": {
    "count": "no persons | {count} person | {count} persons"
  }
}

// locales/sv.json
{
  "person": {
    "count": "inga personer | {count} person | {count} personer"
  }
}
```

```vue
<!-- In component -->
<p>{{ t('person.count', persons.length, { count: persons.length }) }}</p>
```

### Phase 7: Testing Updates

#### 7.1 Update E2E Tests

Update tests to work with i18n. Tests can either:

1. **Option A**: Set a fixed locale for tests (recommended for stability)
2. **Option B**: Test both locales

**Example update for `tests/e2e/global-assumptions.spec.ts`:**

```typescript
import { test, expect } from '@playwright/test'

test.describe('Financial Projections', () => {
  test.beforeEach(async ({ page }) => {
    // Set locale to English for consistent testing
    await page.addInitScript(() => {
      localStorage.setItem('i18n_locale', 'en')
    })
    
    // Login and navigate
    await page.goto('/auth')
    // ... login flow
  })

  test('should display currency values correctly', async ({ page }) => {
    // Test now needs to account for user's currency preference
    const currencyValues = await page.locator('[data-testid="currency-value"]').allTextContents()
    
    // Check that values are formatted (could be $ or kr depending on user preference)
    expect(currencyValues.some(v => v.includes('$') || v.includes('kr'))).toBe(true)
  })
})
```

#### 7.2 Add i18n Unit Tests

Create `tests/unit/i18n.test.ts`:

```typescript
import { describe, it, expect } from 'vitest'
import { useCurrency } from '~/composables/useCurrency'

describe('useCurrency', () => {
  it('should format USD correctly', () => {
    const { formatCurrency } = useCurrency()
    // Mock currency preference to USD
    expect(formatCurrency(1000)).toBe('$1,000')
  })

  it('should format SEK correctly', () => {
    const { formatCurrency } = useCurrency()
    // Mock currency preference to SEK
    expect(formatCurrency(1000)).toMatch(/kr/)
  })

  it('should format compact numbers', () => {
    const { formatCurrencyCompact } = useCurrency()
    expect(formatCurrencyCompact(1_500_000)).toContain('M')
    expect(formatCurrencyCompact(15_000)).toContain('k')
  })
})
```

### Phase 8: Migration and Deployment

#### 8.1 Run Database Migration

```bash
# Generate migration
npm run db:generate

# Review the generated migration file
# Then apply it
npm run db:migrate
```

#### 8.2 Set Default Preferences for Existing Users

Create a script to set default preferences for existing users:

```typescript
// scripts/set-default-preferences.ts
import { db } from "../server/utils/db"
import { users } from "../database/schema"
import { isNull } from "drizzle-orm"

async function setDefaultPreferences() {
  await db
    .update(users)
    .set({
      locale: 'en',
      currency: 'USD',
      updatedAt: new Date(),
    })
    .where(isNull(users.locale))

  console.log('Default preferences set for all users')
}

setDefaultPreferences()
```

Run with: `tsx scripts/set-default-preferences.ts`

#### 8.3 Deployment Checklist

- [ ] All translation keys are complete in both languages
- [ ] Database migration has been applied
- [ ] Existing users have default preferences set
- [ ] All currency formatting uses the new composable
- [ ] All text content uses translation keys
- [ ] E2E tests pass with i18n enabled
- [ ] Manual testing in both languages completed
- [ ] Manual testing with both currencies completed

## Future Enhancements

### Additional Languages

To add a new language (e.g., Norwegian):

1. Add to `nuxt.config.ts` locales array:
```typescript
{
  code: 'no',
  iso: 'no-NO',
  name: 'Norsk',
  file: 'no.json'
}
```

2. Create `locales/no.json` with all translations

3. Update database enum: `ALTER TABLE users ADD CONSTRAINT locale_check CHECK (locale IN ('en', 'sv', 'no'));`

4. Update TypeScript types in validation schemas

5. Add to currency composable locale mapping if needed

### Additional Currencies

To add a new currency (e.g., EUR):

1. Update `i18n.config.ts` numberFormats
2. Update database validation schema
3. Update `useCurrency` composable with proper locale mapping
4. Update UI components that list currencies

### Date/Time Localization

Currently not implemented. If needed:

1. Use `$d()` function from vue-i18n for date formatting
2. Add `datetimeFormats` to `i18n.config.ts`
3. Update components displaying dates

### RTL Language Support

If adding RTL languages (e.g., Arabic):

1. Add `dir` configuration in `nuxt.config.ts`
2. Update CSS with RTL-aware properties
3. Test layout with RTL enabled

## Common Patterns and Examples

### Using Translations in Components

```vue
<script setup lang="ts">
const { t } = useI18n()
</script>

<template>
  <!-- Simple translation -->
  <h1>{{ t('dashboard.title') }}</h1>
  
  <!-- Translation with interpolation -->
  <p>{{ t('common.greeting', { name: userName }) }}</p>
  
  <!-- Translation with pluralization -->
  <p>{{ t('person.count', persons.length, { count: persons.length }) }}</p>
</template>
```

### Using Currency Formatting

```vue
<script setup lang="ts">
const { formatCurrency, formatCurrencyCompact } = useCurrency()
const income = ref(50000)
</script>

<template>
  <!-- Regular formatting -->
  <p>{{ formatCurrency(income) }}</p>
  
  <!-- Compact for large numbers -->
  <p>{{ formatCurrencyCompact(1500000) }}</p>
</template>
```

### Switching Locale Programmatically

```typescript
// In a component or composable
const { setLocale, setCurrency } = useUserPreferences()

// Change language
await setLocale('sv')

// Change currency
await setCurrency('SEK')
```

## Troubleshooting

### Issue: Translations not loading

**Solution**: Ensure the `lazy: true` option is set and files are in the correct `locales/` directory.

### Issue: Currency not updating after change

**Solution**: Ensure components are using the reactive `currency` value from `useUserPreferences()`, not a static value.

### Issue: SSR hydration mismatch

**Solution**: Ensure locale is set before rendering. Use the `onMounted` hook in `useUserPreferences` to sync locale.

### Issue: Tests failing with i18n

**Solution**: Mock the i18n plugin in tests or set a fixed locale in test setup.

## Performance Considerations

1. **Lazy Loading**: Translations are lazy-loaded per locale to reduce initial bundle size
2. **Caching**: User preferences are cached in the composable to avoid repeated API calls
3. **Minimal Re-renders**: Currency formatting uses computed values to minimize re-renders
4. **SSR Optimization**: Locale is set server-side when possible to avoid client-side flicker

## Accessibility

- Language switcher should be keyboard accessible
- Proper `lang` attribute is set on `<html>` tag
- Currency symbols and abbreviations should have proper ARIA labels where needed
- Ensure all translated content maintains semantic HTML structure

## Summary

This implementation plan provides a comprehensive approach to adding i18n and multi-currency support to the Long-Term Budget application. The key principles are:

1. Use `@nuxtjs/i18n` v9 for Nuxt 4 compatibility
2. Store language and currency preferences per user in the database
3. Decouple language from currency selection
4. Format currency only in the frontend, keep raw numbers in the database
5. Use composables for consistent formatting and preference management
6. Update all components to use translations and reactive currency formatting
7. Maintain test coverage with i18n-aware tests

The implementation is designed to be scalable for additional languages and currencies in the future.
